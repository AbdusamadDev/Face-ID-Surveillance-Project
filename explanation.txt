REQUIREMENT:
########################################################################################
explain the way data of backend flows, here is all of my code. Explain the way the 
result is travelling in my code, which is getting the result first, and which is last, 
and which is the main cause of issue of not being sent to browser neither apk nor web 
client, like I mean any kind of client is not getting results from server but being 
printed okay. fully explain the way the program is working, fully, not the code itself, 
but the logic of this code
########################################################################################
___________________________________________________________________________________
the alert manager class
___________________________________________________________________________________
import os
import json
import cv2
from datetime import datetime
from models import Database


class AlertManager:
    def __init__(self, websocket_manager):
        self.websocket_manager = websocket_manager
        self.last_alert_time = {}
        self.face_last_seen = {}
        self.database = Database()

    async def handle_alert(self, detected_face, frame, url):
        now = datetime.now()
        last_alert_time = self.last_alert_time.get(detected_face, datetime.min)
        time_since_last_alert = (now - last_alert_time).total_seconds()

        time_since_last_seen = (
            now - self.face_last_seen.get(detected_face, datetime.min)
        ).total_seconds()

        if time_since_last_seen > 5 and time_since_last_alert > 3:
            self.save_screenshot(detected_face, frame)
            await self.send_alert(detected_face, url)
            self.last_alert_time[detected_face] = now

        self.face_last_seen[detected_face] = now

    def save_screenshot(self, detected_face, frame):
        year, month, day = datetime.now().timetuple()[:3]
        path = f"../media/screenshots/{detected_face}/{year}/{month}/{day}"
        if not os.path.exists(path):
            os.makedirs(path)
        filename = (
            path
            + f"/{datetime.now().hour}-{datetime.now().minute}-{datetime.now().second}.jpg"
        )
        cv2.imwrite(filename, frame)

    async def send_alert(self, detected_face, url):
        details = self.database.get_details(detected_face)
        camera = self.database.get_camera(url)
        camera_details = camera or None

        context = {
            "id": details[0],
            "first_name": detected_face,
            "last_name": details[1],
            "age": details[2],
            "description": details[-1],
            "url": url,
            "camera": camera_details,
        }
        location = (40.9983, 71.67257)
        print(context)
        await self.websocket_manager.broadcast_to_web_clients(
            json.dumps({"event": "all_clients", "context": context})
        )
        await self.websocket_manager.send_to_nearest_apk_client(
            message=json.dumps({"event": "nearest_client", "context": context}),
            location=location,
        )
___________________________________________________________________________________





the recognition class
___________________________________________________________________________________
class FaceRecognition:
    def __init__(self, main_stream):
        self.index = main_stream.index
        self.known_face_names = main_stream.known_face_names
        self.face_model = main_stream.face_model

    async def process_face(self, face):
        embedding = face.embedding
        similarity, index = self.index.search(embedding.reshape(1, -1), 1)
        if similarity[0, 0] < 500:
            return self.known_face_names[index[0, 0]]
        return None
___________________________________________________________________________________






this is handler and main initiation code
___________________________________________________________________________________
import asyncio
import websockets
from web import websocket_manager
import logging
import json

from path import absolute_path
from stream import MainStream

logging.basicConfig(level=logging.DEBUG)


async def websocket_handler(websocket, path):
    # Initial registration process
    location = await websocket.recv()
    location_data = json.loads(location)
    latitude, longitude, state = (
        location_data["latitude"],
        location_data["longitude"],
        location_data["state"],
    )
    await websocket_manager.register(websocket, (latitude, longitude), state)

    try:
        async for message in websocket:
            data = json.loads(message)
            # Process the received message
            # Example: Echo back the message to all web clients and the nearest apk client
            await websocket_manager.broadcast_to_web_clients({"echo": data})
            await websocket_manager.send_to_nearest_apk_client(
                {"echo": data}, (latitude, longitude)
            )

    except websockets.exceptions.ConnectionClosedError as e:
        logging.error(f"Connection closed with error: {e}")
    except json.JSONDecodeError as e:
        logging.error(f"JSON decode error: {e}")
    except Exception as e:
        logging.error(f"Unexpected error: {e}")
    finally:
        await websocket_manager.unregister(websocket)


if __name__ == "__main__":
    # Setup the WebSocket server
    start_server = websockets.serve(websocket_handler, "0.0.0.0", 5000)

    # Instantiate MainStream
    camera_urls = ["http://192.168.1.152:5000/video"]
    stream = MainStream(absolute_path + "/criminals/", camera_urls)

    # Get the event loop
    loop = asyncio.get_event_loop()
    
    # Schedule the WebSocket server
    loop.run_until_complete(start_server)
    logging.info("WebSocket server started. Awaiting client connections...")

    # Schedule the MainStream's coroutine
    loop.run_until_complete(stream.multiple_cameras())

    # Run the event loop
    loop.run_forever()
___________________________________________________________________________________






here is stream class
___________________________________________________________________________________
import asyncio
import time
import logging
from imutils.video import VideoStream
from web import WebSocketManager
from alerts import AlertManager
from recognition import FaceRecognition
from train import FaceTrainer
import websockets


class MainStream:
    def __init__(self, root_dir, camera_urls):
        self.websocket_manager = WebSocketManager()
        self.urls = camera_urls
        self.trainer = FaceTrainer(root_dir)
        self.index = self.trainer.index
        self.known_face_names = self.trainer.known_face_names
        self.face_model = self.trainer.face_model
        self.alert_manager = AlertManager(self.websocket_manager)
        self.face_recognition = FaceRecognition(self)

    async def detect_and_process_faces(self, frame, start, url):
        faces = self.face_model.get(frame)
        detected_faces = await asyncio.gather(
            *(self.face_recognition.process_face(face) for face in faces)
        )
        detected_faces = set(filter(None, detected_faces))

        for result in detected_faces:
            await self.alert_manager.handle_alert(result, frame, url)

    async def continuous_stream_faces(self, url):
        cap = VideoStream(url).start()
        try:
            while True:
                frame = cap.read()
                if frame is None:
                    continue
                current_time = time.time()
                await self.detect_and_process_faces(frame, current_time, url)
        except (KeyboardInterrupt, websockets.exceptions.ConnectionClosedError):
            logging.info(f"Stream {url} terminated.")
        finally:
            cap.stop()

    async def multiple_cameras(self):
        tasks = [self.continuous_stream_faces(url) for url in self.urls]
        await asyncio.gather(*tasks)
___________________________________________________________________________________





here is learner class

___________________________________________________________________________________
import torch
import insightface
import cv2
import os
import numpy as np
import faiss


class FaceTrainer:
    def __init__(self, root_dir):
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

        try:
            self.face_model = insightface.app.FaceAnalysis()
            ctx_id = 0
            self.face_model.prepare(ctx_id=ctx_id)
        except Exception as e:
            print(f"Failed to load models: {e}")
            raise

        self.index, self.known_face_names = self.load_face_encodings(root_dir)
        print(self.index)

    def load_face_encodings(self, root_dir):
        known_face_encodings = []
        known_face_names = []
        for dir_name in os.listdir(root_dir):
            dir_path = os.path.join(root_dir, dir_name)
            if os.path.isdir(dir_path):
                for file_name in os.listdir(dir_path):
                    if file_name.endswith((".jpg", ".png")):
                        image_path = os.path.join(dir_path, file_name)
                        image = cv2.imread(image_path)
                        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
                        faces = self.face_model.get(image)

                        if faces:
                            face = faces[0]
                            embedding = face.embedding
                            known_face_encodings.append(embedding)
                            known_face_names.append(dir_name)

        known_face_encodings = np.array(known_face_encodings)
        index = faiss.IndexFlatL2(known_face_encodings.shape[1])
        index.add(known_face_encodings)
        return index, known_face_names

    @property
    def get_face_model(self):
        return self.face_model
___________________________________________________________________________________




here is websocket manager class
___________________________________________________________________________________
import asyncio
import json
import logging
from geopy.distance import geodesic


logging.basicConfig(level=logging.INFO)


class WebSocketManager:
    def __init__(self):
        self.clients = {}

    async def register(self, websocket, location, state):
        self.clients[websocket] = (location, state)
        logging.info(f"Client registered. Total clients: {len(self.clients)}.")

    async def unregister(self, websocket):
        if websocket in self.clients:
            del self.clients[websocket]
            logging.info(f"Client unregistered. Total clients: {len(self.clients)}.")
        else:
            logging.warning("Attempted to unregister an unknown client.")

    async def send_to_nearest_apk_client(self, message, location):
        nearest_client, _ = self.find_nearest_client(location, client_type="apk")
        if nearest_client:
            await nearest_client.send(json.dumps(message))

    async def broadcast_to_web_clients(self, message):
        web_clients = [
            ws for ws, (_, state) in self.clients.items() if state == "web" and ws.open
        ]
        if web_clients:
            await asyncio.gather(
                *(client.send(json.dumps(message)) for client in web_clients)
            )

    def find_nearest_client(self, location, client_type=None):
        nearest_client = None
        nearest_distance = float("inf")
        for client, (client_loc, state) in self.clients.items():
            if client_type and state != client_type:
                continue
            distance = geodesic(location, client_loc).kilometers
            if distance < nearest_distance:
                nearest_distance = distance
                nearest_client = client
        return nearest_client, nearest_distance


websocket_manager = WebSocketManager()
___________________________________________________________________________________